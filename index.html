<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>三维点电荷电场线可视化模拟器（带二维剖面视图）</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        /* 主控制面板 */
        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            background: rgba(25, 25, 35, 0.85);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 20px;
            border-radius: 12px;
            max-width: 320px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            max-height: 85vh;
        }
        
        .control-group {
            margin-bottom: 18px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #4fc3f7;
            display: flex;
            align-items: center;
        }
        
        .control-group h3 i {
            margin-right: 8px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #b0bec5;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .slider-container input[type="range"] {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .slider-container span {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
            color: #fff;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .control-group select, .control-group button {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-group select:hover, .control-group button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: #4fc3f7;
        }
        
        .control-group button {
            background: linear-gradient(135deg, #4fc3f7 0%, #2196f3 100%);
            border: none;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .control-group button:hover {
            background: linear-gradient(135deg, #29b6f6 0%, #1976d2 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }
        
        /* 信息面板 */
        #info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 100;
            background: rgba(25, 25, 35, 0.85);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 11px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 300px;
        }
        
        #info h4 {
            margin: 0 0 6px 0;
            color: #4fc3f7;
            font-size: 12px;
        }
        
        /* 图例 */
        #legend {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(25, 25, 35, 0.85);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            font-size: 11px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        /* 电荷标签 */
        .charge-label {
            position: absolute;
            color: white;
            font-weight: bold;
            background: rgba(0,0,0,0.7);
            padding: 3px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1000;
            font-size: 11px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        /* 加载动画 */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #4fc3f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 电场强度显示 */
        #field-strength {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(25, 25, 35, 0.85);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 11px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 250px;
        }
        
        #field-strength h4 {
            margin: 0 0 8px 0;
            color: #4fc3f7;
            font-size: 12px;
        }
        
        .field-value {
            font-size: 14px;
            color: #69f0ae;
            margin: 5px 0;
        }
        
        /* 状态信息 */
        #status {
            position: absolute;
            top: 15px;
            left: 350px;
            z-index: 100;
            background: rgba(25, 25, 35, 0.85);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            font-size: 11px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 280px;
        }
        
        #status h4 {
            margin: 0 0 10px 0;
            color: #4fc3f7;
            font-size: 12px;
        }
        
        .status-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .status-label {
            color: #b0bec5;
        }
        
        .status-value {
            color: #fff;
            font-weight: bold;
        }
        
        /* 二维剖面视图容器 */
        #sectionViewContainer {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 90;
            background: rgba(25, 25, 35, 0.95);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 320px;
            height: 320px;
        }
        
        #sectionViewContainer h4 {
            margin: 0 0 10px 0;
            color: #4fc3f7;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        #sectionView {
            width: 100%;
            height: calc(100% - 40px);
            background: rgba(10, 10, 20, 0.7);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .section-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
        }
        
        .section-btn {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            text-align: center;
            min-width: 60px;
        }
        
        .section-btn:hover, .section-btn.active {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
        }
        
        /* 响应式调整 */
        @media (max-width: 1200px) {
            #status {
                left: 350px;
                top: 350px;
            }
            
            #sectionViewContainer {
                top: 350px;
                right: 15px;
            }
        }
        
        @media (max-width: 900px) {
            #controls, #legend, #info, #field-strength, #status, #sectionViewContainer {
                position: relative;
                max-width: 100%;
                width: calc(100% - 30px);
                margin: 10px auto;
                left: 0;
                right: 0;
                top: auto;
                bottom: auto;
            }
            #container {
                padding-top: 10px;
                height: auto;
                overflow-y: auto;
            }
        }
        
        /* 隐藏二维视图的默认状态 */
        #sectionViewContainer {
            display: block; /* 默认显示 */
        }
    </style>
    <!-- 添加Font Awesome图标 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- 加载动画 -->
    <div id="loading">
        <div class="spinner"></div>
    </div>
    
    <div id="container">
        <!-- 主控制面板 -->
        <div id="controls">
            <div class="control-group">
                <h3><i class="fas fa-cog"></i> 电荷配置</h3>
                <select id="chargeConfig">
                    <option value="positive">两正电荷</option>
                    <option value="mixed">一正一负</option>
                    <option value="negative">两负电荷</option>
                    <option value="custom">自定义配置</option>
                </select>
            </div>
            
            <div class="control-group">
                <h3><i class="fas fa-bolt"></i> 电荷参数</h3>
                <div class="slider-container">
                    <label>电荷A电量:</label>
                    <input type="range" id="chargeA" min="-5" max="5" step="0.1" value="1.0">
                    <span id="chargeAValue">+1.0</span>
                </div>
                <div class="slider-container">
                    <label>电荷B电量:</label>
                    <input type="range" id="chargeB" min="-5" max="5" step="0.1" value="1.0">
                    <span id="chargeBValue">+1.0</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3><i class="fas fa-arrows-alt"></i> 电荷A位置</h3>
                <div class="slider-container">
                    <label>X:</label>
                    <input type="range" id="posAX" min="-5" max="5" step="0.1" value="-2.0">
                    <span id="posAXValue">-2.0</span>
                </div>
                <div class="slider-container">
                    <label>Y:</label>
                    <input type="range" id="posAY" min="-5" max="5" step="0.1" value="0.0">
                    <span id="posAYValue">0.0</span>
                </div>
                <div class="slider-container">
                    <label>Z:</label>
                    <input type="range" id="posAZ" min="-5" max="5" step="0.1" value="0.0">
                    <span id="posAZValue">0.0</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3><i class="fas fa-arrows-alt"></i> 电荷B位置</h3>
                <div class="slider-container">
                    <label>X:</label>
                    <input type="range" id="posBX" min="-5" max="5" step="0.1" value="2.0">
                    <span id="posBXValue">2.0</span>
                </div>
                <div class="slider-container">
                    <label>Y:</label>
                    <input type="range" id="posBY" min="-5" max="5" step="0.1" value="0.0">
                    <span id="posBYValue">0.0</span>
                </div>
                <div class="slider-container">
                    <label>Z:</label>
                    <input type="range" id="posBZ" min="-5" max="5" step="0.1" value="0.0">
                    <span id="posBZValue">0.0</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3><i class="fas fa-sliders-h"></i> 可视化设置</h3>
                <div class="slider-container">
                    <label>电场线基数:</label>
                    <input type="range" id="fieldLineBase" min="5" max="50" step="1" value="20">
                    <span id="fieldLineBaseValue">20</span>
                </div>
                <div class="slider-container">
                    <label>箭头密度:</label>
                    <input type="range" id="arrowDensity" min="1" max="10" step="1" value="3">
                    <span id="arrowDensityValue">3</span>
                </div>
                <div class="slider-container">
                    <label>电场线长度:</label>
                    <input type="range" id="fieldLineLength" min="1" max="15" step="0.5" value="5.0">
                    <span id="fieldLineLengthValue">5.0</span>
                </div>
                <div class="slider-container">
                    <label>显示模式:</label>
                    <select id="displayMode">
                        <option value="lines">电场线</option>
                        <option value="vectors">电场矢量</option>
                        <option value="both">两者都显示</option>
                    </select>
                </div>
                <div class="slider-container">
                    <label>二维剖面平面:</label>
                    <select id="sectionPlane">
                        <option value="xy">XY平面</option>
                        <option value="xz">XZ平面</option>
                        <option value="yz">YZ平面</option>
                    </select>
                </div>
                <button id="resetView">重置视角</button>
                <button id="exportConfig">导出配置</button>
                <button id="addCharge">添加第三个电荷</button>
                <button id="toggleSectionView">隐藏二维视图</button>
            </div>
        </div>
        
        <!-- 状态信息 -->
        <div id="status">
            <h4><i class="fas fa-chart-bar"></i> 系统状态</h4>
            <div class="status-item">
                <span class="status-label">电场线总数:</span>
                <span id="totalFieldLines" class="status-value">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">电荷A电场线:</span>
                <span id="chargeALines" class="status-value">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">电荷B电场线:</span>
                <span id="chargeBLines" class="status-value">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">电荷密度比:</span>
                <span id="densityRatio" class="status-value">1:1</span>
            </div>
            <div class="status-item">
                <span class="status-label">二维剖面:</span>
                <span id="sectionPlaneValue" class="status-value">XY平面</span>
            </div>
        </div>
        
        <!-- 二维剖面视图 -->
        <div id="sectionViewContainer">
            <h4>
                <span><i class="fas fa-chart-area"></i> 二维剖面视图</span>
                <span style="font-size: 10px; color: #b0bec5;">物理书风格</span>
            </h4>
            <canvas id="sectionView"></canvas>
            <div class="section-controls">
                <button class="section-btn active" data-plane="xy">XY平面</button>
                <button class="section-btn" data-plane="xz">XZ平面</button>
                <button class="section-btn" data-plane="yz">YZ平面</button>
                <button class="section-btn" id="showFieldVectors">场强矢量</button>
                <button class="section-btn" id="toggleGrid">网格</button>
            </div>
        </div>
        
        <!-- 图例 -->
        <div id="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ff5252;"></div>
                <span>正电荷 (+)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #448aff;"></div>
                <span>负电荷 (-)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #69f0ae; border-radius: 0;"></div>
                <span>正电荷电场线</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff5252; border-radius: 0;"></div>
                <span>负电荷电场线</span>
            </div>
            <div class="legend-item" style="margin-top: 10px; color: #b0bec5; font-size: 10px;">
                <i class="fas fa-info-circle" style="margin-right: 5px;"></i>
                <span>电场线密度∝电荷量</span>
            </div>
        </div>
        
        <!-- 电场强度显示 -->
        <div id="field-strength">
            <h4><i class="fas fa-wave-square"></i> 电场强度</h4>
            <div>当前位置: <span id="currentPos">(0.0, 0.0, 0.0)</span></div>
            <div>电场强度: <span id="fieldMag" class="field-value">0.00 N/C</span></div>
            <div>方向: <span id="fieldDir">(0.00, 0.00, 0.00)</span></div>
        </div>
        
        <!-- 信息面板 -->
        <div id="info">
            <h4>交互指南</h4>
            <div>• 左键拖拽: 旋转视角</div>
            <div>• 滚轮: 缩放视图</div>
            <div>• 右键拖拽: 平移视图</div>
            <div>• 双击: 重置视角</div>
            <div>• 空格键: 暂停/继续动画</div>
            <div>• 鼠标移动: 查看当前位置电场强度</div>
            <div>• 二维视图: 显示电场线剖面</div>
        </div>
    </div>

    <!-- Three.js库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls用于相机控制 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <script>
        // 隐藏加载动画
        window.addEventListener('load', function() {
            setTimeout(function() {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(function() {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
            }, 500);
        });
        
        // 场景设置
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        
        // 相机设置
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 15);
        
        // 渲染器
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);
        
        // 添加轨道控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 50;
        
        // 光照设置
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(5, 10, 5);
        directionalLight1.castShadow = true;
        directionalLight1.shadow.mapSize.width = 2048;
        directionalLight1.shadow.mapSize.height = 2048;
        scene.add(directionalLight1);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-5, -5, -5);
        scene.add(directionalLight2);
        
        // 坐标轴
        const axesHelper = new THREE.AxesHelper(5);
        axesHelper.lineWidth = 2;
        scene.add(axesHelper);
        
        // 网格地面
        const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
        gridHelper.position.y = -5;
        scene.add(gridHelper);
        
        // 二维剖面视图类
        class SectionView {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.plane = 'xy'; // 默认XY平面
                this.showVectors = false;
                this.showGrid = true;
                this.charges = [];
                this.fieldLines = [];
                this.scale = 25; // 像素/单位（增加缩放比例，使视图更紧凑）
                this.offsetX = this.canvas.width / 2;
                this.offsetY = this.canvas.height / 2;
                this.gridSize = 1.0; // 网格大小（单位）
                
                // 设置canvas尺寸
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight - 40;
                this.offsetX = this.canvas.width / 2;
                this.offsetY = this.canvas.height / 2;
                this.draw();
            }
            
            setPlane(plane) {
                this.plane = plane;
                this.draw();
            }
            
            setCharges(charges) {
                this.charges = charges;
                this.draw();
            }
            
            setFieldLines(fieldLines) {
                this.fieldLines = fieldLines;
                this.draw();
            }
            
            toggleVectors() {
                this.showVectors = !this.showVectors;
                this.draw();
                return this.showVectors;
            }
            
            toggleGrid() {
                this.showGrid = !this.showGrid;
                this.draw();
                return this.showGrid;
            }
            
            // 将三维坐标转换为二维坐标（根据当前剖面平面）
            projectTo2D(point3D) {
                let x, y;
                
                switch(this.plane) {
                    case 'xy':
                        x = point3D.x;
                        y = point3D.y;
                        break;
                    case 'xz':
                        x = point3D.x;
                        y = point3D.z;
                        break;
                    case 'yz':
                        x = point3D.y;
                        y = point3D.z;
                        break;
                }
                
                // 转换为canvas坐标
                const canvasX = this.offsetX + x * this.scale;
                const canvasY = this.offsetY - y * this.scale; // Y轴反转
                
                return { x: canvasX, y: canvasY };
            }
            
            // 绘制网格
            drawGrid() {
                if (!this.showGrid) return;
                
                this.ctx.strokeStyle = 'rgba(100, 100, 120, 0.3)';
                this.ctx.lineWidth = 1;
                
                // 计算可见范围
                const minX = -Math.floor(this.offsetX / this.scale);
                const maxX = Math.floor((this.canvas.width - this.offsetX) / this.scale);
                const minY = -Math.floor(this.offsetY / this.scale);
                const maxY = Math.floor((this.canvas.height - this.offsetY) / this.scale);
                
                // 绘制垂直线
                for (let x = minX; x <= maxX; x += this.gridSize) {
                    const canvasX = this.offsetX + x * this.scale;
                    this.ctx.beginPath();
                    this.ctx.moveTo(canvasX, 0);
                    this.ctx.lineTo(canvasX, this.canvas.height);
                    this.ctx.stroke();
                    
                    // 绘制坐标标签
                    if (Math.abs(x) > 0.1 && x !== 0) {
                        this.ctx.fillStyle = 'rgba(180, 180, 200, 0.7)';
                        this.ctx.font = '9px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(x.toFixed(1), canvasX, this.canvas.height - 5);
                    }
                }
                
                // 绘制水平线
                for (let y = minY; y <= maxY; y += this.gridSize) {
                    const canvasY = this.offsetY - y * this.scale;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, canvasY);
                    this.ctx.lineTo(this.canvas.width, canvasY);
                    this.ctx.stroke();
                    
                    // 绘制坐标标签
                    if (Math.abs(y) > 0.1 && y !== 0) {
                        this.ctx.fillStyle = 'rgba(180, 180, 200, 0.7)';
                        this.ctx.font = '9px Arial';
                        this.ctx.textAlign = 'left';
                        this.ctx.fillText(y.toFixed(1), 5, canvasY - 5);
                    }
                }
                
                // 绘制坐标轴
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.lineWidth = 2;
                
                // X轴
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.offsetY);
                this.ctx.lineTo(this.canvas.width, this.offsetY);
                this.ctx.stroke();
                
                // Y轴
                this.ctx.beginPath();
                this.ctx.moveTo(this.offsetX, 0);
                this.ctx.lineTo(this.offsetX, this.canvas.height);
                this.ctx.stroke();
                
                // 坐标轴标签
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = '11px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.fillText(this.getAxisLabel('x'), this.canvas.width - 10, this.offsetY - 10);
                this.ctx.textAlign = 'left';
                this.ctx.fillText(this.getAxisLabel('y'), this.offsetX + 10, 15);
                
                // 绘制原点标签
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.fillText('0', this.offsetX - 5, this.offsetY + 15);
            }
            
            getAxisLabel(axis) {
                switch(this.plane) {
                    case 'xy':
                        return axis === 'x' ? 'X轴' : 'Y轴';
                    case 'xz':
                        return axis === 'x' ? 'X轴' : 'Z轴';
                    case 'yz':
                        return axis === 'x' ? 'Y轴' : 'Z轴';
                }
            }
            
            // 绘制电荷 - 修改：点电荷大小固定
            drawCharges() {
                this.charges.forEach(charge => {
                    const pos2D = this.projectTo2D(charge.position);
                    const radius = 8; // 固定半径，点电荷没有体积
                    
                    // 绘制电荷圆
                    this.ctx.beginPath();
                    this.ctx.arc(pos2D.x, pos2D.y, radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = charge.charge > 0 ? '#ff5252' : '#448aff';
                    this.ctx.fill();
                    
                    // 绘制电荷边框
                    this.ctx.strokeStyle = charge.charge > 0 ? '#ff8a80' : '#82b1ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // 绘制电荷符号和数值 - 字体大小固定
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 12px Arial'; // 固定字体大小
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const sign = charge.charge > 0 ? '+' : '−';
                    const value = Math.abs(charge.charge).toFixed(1);
                    this.ctx.fillText(`${sign}${value}`, pos2D.x, pos2D.y);
                    
                    // 绘制电荷标签
                    this.ctx.font = 'bold 11px Arial';
                    this.ctx.fillText(`电荷${charge.name}`, pos2D.x, pos2D.y - radius - 12);
                });
            }
            
            // 绘制电场线
            drawFieldLines() {
                this.fieldLines.forEach(line => {
                    const { points, color } = line;
                    
                    if (points.length < 2) return;
                    
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 1.5; // 稍细的线
                    this.ctx.beginPath();
                    
                    // 绘制电场线
                    for (let i = 0; i < points.length; i++) {
                        const point2D = this.projectTo2D(points[i]);
                        
                        if (i === 0) {
                            this.ctx.moveTo(point2D.x, point2D.y);
                        } else {
                            this.ctx.lineTo(point2D.x, point2D.y);
                        }
                    }
                    
                    this.ctx.stroke();
                    
                    // 绘制箭头（每隔一段距离）
                    const arrowSpacing = 25; // 像素距离
                    let accumulatedDist = 0;
                    
                    for (let i = 1; i < points.length; i++) {
                        const prev2D = this.projectTo2D(points[i-1]);
                        const curr2D = this.projectTo2D(points[i]);
                        
                        const dx = curr2D.x - prev2D.x;
                        const dy = curr2D.y - prev2D.y;
                        const segmentDist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (accumulatedDist + segmentDist >= arrowSpacing) {
                            // 计算箭头位置
                            const ratio = (arrowSpacing - accumulatedDist) / segmentDist;
                            const arrowX = prev2D.x + dx * ratio;
                            const arrowY = prev2D.y + dy * ratio;
                            
                            // 绘制箭头
                            this.drawArrow(arrowX, arrowY, dx, dy, color);
                            
                            accumulatedDist = 0; // 重置距离
                        } else {
                            accumulatedDist += segmentDist;
                        }
                    }
                });
            }
            
            // 绘制箭头
            drawArrow(x, y, dx, dy, color) {
                const length = Math.sqrt(dx*dx + dy*dy);
                if (length === 0) return;
                
                const unitX = dx / length;
                const unitY = dy / length;
                
                const arrowLength = 12; // 较小的箭头
                const arrowWidth = 6;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(Math.atan2(dy, dx));
                
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(-arrowLength, arrowWidth/2);
                this.ctx.lineTo(-arrowLength, -arrowWidth/2);
                this.ctx.closePath();
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            // 绘制电场矢量场
            drawVectorField(chargeManager) {
                if (!this.showVectors) return;
                
                const gridStep = 1.0; // 单位
                const vectorScale = 0.4; // 矢量缩放因子（更小的矢量）
                
                // 计算可见范围
                const minX = -Math.floor(this.offsetX / this.scale);
                const maxX = Math.floor((this.canvas.width - this.offsetX) / this.scale);
                const minY = -Math.floor(this.offsetY / this.scale);
                const maxY = Math.floor((this.canvas.height - this.offsetY) / this.scale);
                
                for (let x = minX; x <= maxX; x += gridStep) {
                    for (let y = minY; y <= maxY; y += gridStep) {
                        // 创建三维点（根据当前平面）
                        let point3D;
                        switch(this.plane) {
                            case 'xy':
                                point3D = new THREE.Vector3(x, y, 0);
                                break;
                            case 'xz':
                                point3D = new THREE.Vector3(x, 0, y);
                                break;
                            case 'yz':
                                point3D = new THREE.Vector3(0, x, y);
                                break;
                        }
                        
                        // 检查是否太接近电荷
                        let tooClose = false;
                        for (const charge of this.charges) {
                            const dx = point3D.x - charge.position.x;
                            const dy = point3D.y - charge.position.y;
                            const dz = point3D.z - charge.position.z;
                            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                            
                            if (distance < 0.8) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        if (tooClose) continue;
                        
                        // 计算电场
                        const field = chargeManager.calculateTotalField(point3D);
                        const fieldStrength = field.length();
                        
                        if (fieldStrength < 0.01) continue;
                        
                        // 将电场矢量投影到当前平面
                        let field2D;
                        switch(this.plane) {
                            case 'xy':
                                field2D = { x: field.x, y: field.y };
                                break;
                            case 'xz':
                                field2D = { x: field.x, y: field.z };
                                break;
                            case 'yz':
                                field2D = { x: field.y, y: field.z };
                                break;
                        }
                        
                        // 绘制矢量
                        const pos2D = this.projectTo2D(point3D);
                        const vecLength = Math.min(25, fieldStrength * vectorScale * this.scale); // 限制最大长度
                        
                        this.drawVector(pos2D.x, pos2D.y, field2D.x, field2D.y, vecLength);
                    }
                }
            }
            
            // 绘制矢量
            drawVector(x, y, dx, dy, length) {
                const angle = Math.atan2(dy, dx);
                const arrowLength = Math.min(length, 25);
                
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(angle);
                
                // 根据场强设置颜色（从蓝到红）
                const strength = Math.sqrt(dx*dx + dy*dy);
                const maxStrength = 5.0;
                const normalized = Math.min(strength / maxStrength, 1.0);
                const r = Math.floor(normalized * 255);
                const g = 0;
                const b = Math.floor((1 - normalized) * 255);
                const color = `rgb(${r}, ${g}, ${b})`;
                
                // 绘制矢量线
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(arrowLength, 0);
                this.ctx.stroke();
                
                // 绘制箭头
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.moveTo(arrowLength, 0);
                this.ctx.lineTo(arrowLength - 6, 4);
                this.ctx.lineTo(arrowLength - 6, -4);
                this.ctx.closePath();
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            // 主要绘制函数
            draw(chargeManager) {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 绘制背景
                this.ctx.fillStyle = 'rgba(10, 10, 20, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 绘制网格
                this.drawGrid();
                
                // 绘制电场线
                this.drawFieldLines();
                
                // 绘制电荷
                this.drawCharges();
                
                // 绘制矢量场（如果启用）
                if (chargeManager && this.showVectors) {
                    this.drawVectorField(chargeManager);
                }
                
                // 绘制标题
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = 'bold 12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`二维剖面视图 (${this.getPlaneName()})`, this.canvas.width / 2, 20);
            }
            
            getPlaneName() {
                switch(this.plane) {
                    case 'xy': return 'XY平面';
                    case 'xz': return 'XZ平面';
                    case 'yz': return 'YZ平面';
                    default: return '未知平面';
                }
            }
            
            // 从三维电场线提取二维数据
            extractFieldLines(charges) {
                const fieldLines2D = [];
                
                charges.forEach(charge => {
                    charge.fieldLines.forEach(line => {
                        const geometry = line.geometry;
                        const points3D = geometry.attributes.position.array;
                        const points = [];
                        
                        // 提取点并转换为二维
                        for (let i = 0; i < points3D.length; i += 3) {
                            const point3D = {
                                x: points3D[i],
                                y: points3D[i + 1],
                                z: points3D[i + 2]
                            };
                            points.push(point3D);
                        }
                        
                        // 确定颜色
                        const isPositive = charge.charge > 0;
                        const color = isPositive ? '#69f0ae' : '#ff5252';
                        
                        fieldLines2D.push({ points, color });
                    });
                });
                
                return fieldLines2D;
            }
        }
        
        // 点电荷类
        class PointCharge {
            constructor(name, position, charge) {
                this.name = name;
                this.position = position.clone();
                this.charge = charge;
                this.mesh = null;
                this.label = null;
                this.glow = null;
                this.fieldLines = [];
                this.arrows = [];
                this.fieldVectors = [];
                this.createMesh();
            }
            
            createMesh() {
                // 创建电荷球体
                const geometry = new THREE.SphereGeometry(0.35, 32, 32);
                const color = this.charge > 0 ? 0xff5252 : 0x448aff;
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.3),
                    shininess: 100,
                    specular: 0x222222
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.castShadow = true;
                
                // 添加发光效果
                const glowGeometry = new THREE.SphereGeometry(0.45, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.BackSide
                });
                
                this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.glow.position.copy(this.position);
                
                // 创建标签
                this.createLabel();
                
                // 添加到场景
                scene.add(this.mesh);
                scene.add(this.glow);
                scene.add(this.label);
            }
            
            createLabel() {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                
                // 绘制标签背景
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制电荷符号
                context.fillStyle = this.charge > 0 ? '#ff5252' : '#448aff';
                context.font = 'bold 24px Arial';
                context.textAlign = 'center';
                context.fillText(this.charge > 0 ? '+' : '−', canvas.width/2 - 15, canvas.height/2 + 8);
                
                // 绘制电荷值
                context.fillStyle = '#ffffff';
                context.font = 'bold 20px Arial';
                context.fillText(Math.abs(this.charge).toFixed(1), canvas.width/2 + 15, canvas.height/2 + 8);
                
                // 绘制电荷名称
                context.fillStyle = '#ffffff';
                context.font = 'bold 16px Arial';
                context.fillText(this.name, canvas.width/2, 20);
                
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                
                this.label = new THREE.Sprite(labelMaterial);
                this.label.scale.set(2, 1, 1);
                this.label.position.copy(this.position).add(new THREE.Vector3(0, 0.8, 0));
            }
            
            updateLabel() {
                // 更新标签内容，但不重新创建标签对象
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                
                // 绘制标签背景
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制电荷符号
                context.fillStyle = this.charge > 0 ? '#ff5252' : '#448aff';
                context.font = 'bold 24px Arial';
                context.textAlign = 'center';
                context.fillText(this.charge > 0 ? '+' : '−', canvas.width/2 - 15, canvas.height/2 + 8);
                
                // 绘制电荷值
                context.fillStyle = '#ffffff';
                context.font = 'bold 20px Arial';
                context.fillText(Math.abs(this.charge).toFixed(1), canvas.width/2 + 15, canvas.height/2 + 8);
                
                // 绘制电荷名称
                context.fillStyle = '#ffffff';
                context.font = 'bold 16px Arial';
                context.fillText(this.name, canvas.width/2, 20);
                
                // 更新现有标签的纹理
                const texture = new THREE.CanvasTexture(canvas);
                if (this.label && this.label.material) {
                    // 释放旧纹理内存
                    if (this.label.material.map) {
                        this.label.material.map.dispose();
                    }
                    this.label.material.map = texture;
                    this.label.material.needsUpdate = true;
                }
            }
            
            updateColor() {
                const color = this.charge > 0 ? 0xff5252 : 0x448aff;
                this.mesh.material.color = new THREE.Color(color);
                this.mesh.material.emissive = new THREE.Color(color).multiplyScalar(0.3);
                this.glow.material.color = new THREE.Color(color);
                this.updateLabel(); // 更新标签颜色和符号
            }
            
            updatePosition() {
                this.mesh.position.copy(this.position);
                this.glow.position.copy(this.position);
                if (this.label) {
                    this.label.position.copy(this.position).add(new THREE.Vector3(0, 0.8, 0));
                }
            }
            
            clearFieldVisualization() {
                this.fieldLines.forEach(line => scene.remove(line));
                this.arrows.forEach(arrow => scene.remove(arrow));
                this.fieldVectors.forEach(vector => scene.remove(vector));
                
                this.fieldLines = [];
                this.arrows = [];
                this.fieldVectors = [];
            }
            
            // 计算该电荷在给定位置产生的电场
            calculateFieldAt(point) {
                const k = 1.0; // 库仑常数，设为1简化计算
                const r = new THREE.Vector3().subVectors(point, this.position);
                const distance = r.length();
                
                if (distance < 0.01) return new THREE.Vector3(0, 0, 0);
                
                const fieldStrength = k * this.charge / (distance * distance);
                const unitR = r.clone().normalize();
                
                return unitR.multiplyScalar(fieldStrength);
            }
            
            // 获取基于电荷量的电场线密度
            getFieldLineDensity(baseDensity) {
                // 电场线密度与电荷量绝对值成正比
                // 最小密度为5，最大密度为100
                const minDensity = 5;
                const maxDensity = 100;
                
                // 计算密度：基数 * |电荷量|
                let density = baseDensity * Math.abs(this.charge);
                
                // 限制在最小和最大值之间
                density = Math.max(minDensity, Math.min(maxDensity, density));
                
                return Math.round(density);
            }
        }
        
        // 电荷管理器
        class ChargeManager {
            constructor() {
                this.charges = [];
                this.fieldLineParams = {
                    baseDensity: 20,  // 电场线基数（每条单位电荷的电场线数量）
                    arrowDensity: 3,
                    maxLength: 5.0,
                    displayMode: 'lines'
                };
                this.gridVectors = [];
                this.sectionView = null;
            }
            
            setSectionView(sectionView) {
                this.sectionView = sectionView;
            }
            
            addCharge(name, position, charge) {
                const newCharge = new PointCharge(name, position, charge);
                this.charges.push(newCharge);
                return newCharge;
            }
            
            removeCharge(name) {
                const index = this.charges.findIndex(charge => charge.name === name);
                if (index !== -1) {
                    const charge = this.charges[index];
                    charge.clearFieldVisualization();
                    scene.remove(charge.mesh);
                    scene.remove(charge.glow);
                    scene.remove(charge.label);
                    this.charges.splice(index, 1);
                }
            }
            
            // 计算所有电荷在给定位置的总电场
            calculateTotalField(point) {
                const totalField = new THREE.Vector3(0, 0, 0);
                
                this.charges.forEach(charge => {
                    totalField.add(charge.calculateFieldAt(point));
                });
                
                return totalField;
            }
            
            // 绘制电场线
            drawFieldLines() {
                // 清除所有电场可视化
                this.charges.forEach(charge => {
                    charge.clearFieldVisualization();
                });
                
                // 清除网格矢量场
                this.clearGridVectors();
                
                // 根据显示模式绘制
                if (this.fieldLineParams.displayMode === 'lines' || this.fieldLineParams.displayMode === 'both') {
                    this.drawElectricFieldLines();
                }
                
                if (this.fieldLineParams.displayMode === 'vectors' || this.fieldLineParams.displayMode === 'both') {
                    this.drawVectorField();
                }
                
                // 更新二维剖面视图
                this.updateSectionView();
                
                // 更新状态信息
                this.updateStatus();
            }
            
            // 绘制电场线 - 已修复负电荷周围电场线消失的问题并修改了方向
            drawElectricFieldLines() {
                const maxSteps = 300;
                const stepSize = 0.05;
                
                // 记录总电场线数量
                let totalLines = 0;
                let chargeLines = {};
                
                this.charges.forEach(charge => {
                    const isPositive = charge.charge > 0;
                    
                    // 根据电荷量计算电场线密度
                    const density = charge.getFieldLineDensity(this.fieldLineParams.baseDensity);
                    
                    // 记录该电荷的电场线数量
                    chargeLines[charge.name] = density;
                    totalLines += density;
                    
                    // 为每个电荷绘制电场线
                    for (let i = 0; i < density; i++) {
                        // 在球面上均匀分布起始点
                        const phi = Math.acos(2 * (i / density) - 1);
                        const theta = Math.PI * (1 + Math.sqrt(5)) * i;
                        
                        let start;
                        if (isPositive) {
                            // 正电荷：从电荷表面附近开始，向外
                            start = new THREE.Vector3(
                                charge.position.x + 0.4 * Math.sin(phi) * Math.cos(theta),
                                charge.position.y + 0.4 * Math.sin(phi) * Math.sin(theta),
                                charge.position.z + 0.4 * Math.cos(phi)
                            );
                        } else {
                            // 负电荷：从电荷外部较近处开始，指向电荷
                            // 使用更近的起始距离，确保负电荷周围也有电场线
                            const startDistance = 0.8; // 从电荷表面0.8单位距离开始
                            start = new THREE.Vector3(
                                charge.position.x + startDistance * Math.sin(phi) * Math.cos(theta),
                                charge.position.y + startDistance * Math.sin(phi) * Math.sin(theta),
                                charge.position.z + startDistance * Math.cos(phi)
                            );
                        }
                        
                        // 跟踪电场线
                        const points = [start.clone()];
                        let current = start.clone();
                        let steps = 0;
                        
                        while (steps < maxSteps) {
                            const field = this.calculateTotalField(current);
                            if (field.length() < 0.0001) break;
                            
                            // 确定积分方向
                            let direction = field.clone().normalize();
                            
                            // 对于正电荷：沿着电场方向（向外）
                            // 对于负电荷：逆着电场方向（向内指向电荷）
                            if (isPositive) {
                                // 正电荷：沿着电场方向
                                direction.multiplyScalar(stepSize);
                            } else {
                                // 负电荷：逆着电场方向（指向电荷）
                                direction.multiplyScalar(-stepSize);
                            }
                            
                            current.add(direction);
                            points.push(current.clone());
                            
                            // 停止条件
                            const distToCharge = current.distanceTo(charge.position);
                            
                            // 检查是否接近任何电荷
                            let tooClose = false;
                            for (const otherCharge of this.charges) {
                                if (otherCharge !== charge && current.distanceTo(otherCharge.position) < 0.5) {
                                    tooClose = true;
                                    break;
                                }
                            }
                            
                            if (tooClose) {
                                break;
                            }
                            
                            // 正电荷：远离到一定距离停止
                            // 负电荷：接近电荷到一定距离停止
                            if (isPositive) {
                                if (distToCharge > this.fieldLineParams.maxLength) {
                                    break;
                                }
                            } else {
                                // 负电荷：当接近电荷到0.35时停止（刚好在电荷表面附近）
                                if (distToCharge < 0.35) {
                                    break;
                                }
                                // 如果负电荷意外远离电荷太远，也停止
                                if (distToCharge > this.fieldLineParams.maxLength) {
                                    break;
                                }
                            }
                            
                            steps++;
                        }
                        
                        if (points.length > 2) {
                            // 创建电场线
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            // 修改这里：负电荷使用不同的颜色（红色）
                            const lineColor = isPositive ? 0x69f0ae : 0xff5252; // 正电荷用绿色，负电荷用红色
                            const material = new THREE.LineBasicMaterial({ 
                                color: lineColor,
                                linewidth: 2,
                                transparent: true,
                                opacity: 0.7
                            });
                            const line = new THREE.Line(geometry, material);
                            scene.add(line);
                            charge.fieldLines.push(line);
                            
                            // 添加方向箭头
                            const arrowSpacing = Math.max(2, Math.floor(points.length / (this.fieldLineParams.arrowDensity + 1)));
                            for (let j = arrowSpacing; j < points.length - arrowSpacing; j += arrowSpacing) {
                                if (j < points.length - 1) {
                                    let arrowDir;
                                    
                                    // 修改这里：负电荷的箭头方向
                                    if (isPositive) {
                                        // 正电荷：箭头向外（从电荷指向外）
                                        arrowDir = new THREE.Vector3()
                                            .subVectors(points[j + 1], points[j])
                                            .normalize();
                                    } else {
                                        // 负电荷：箭头向内（指向电荷）
                                        // 因为负电荷的电场线是从外指向内，所以箭头方向应该是从外指向内
                                        arrowDir = new THREE.Vector3()
                                            .subVectors(points[j], points[j + 1])  // 注意：这里改为points[j]减去points[j+1]，确保箭头指向电荷
                                            .normalize();
                                    }
                                    
                                    // 修改箭头颜色以匹配电场线颜色
                                    const arrow = new THREE.ArrowHelper(
                                        arrowDir,
                                        points[j],
                                        0.3,
                                        lineColor,  // 使用相同的颜色
                                        0.15,
                                        0.08
                                    );
                                    scene.add(arrow);
                                    charge.arrows.push(arrow);
                                }
                            }
                        }
                    }
                });
                
                // 保存用于状态显示
                this.lastLineCounts = chargeLines;
                this.lastTotalLines = totalLines;
            }
            
            // 绘制矢量场
            drawVectorField() {
                const gridSize = 10;
                const gridStep = 1.0;
                
                for (let x = -gridSize/2; x <= gridSize/2; x += gridStep) {
                    for (let y = -gridSize/2; y <= gridSize/2; y += gridStep) {
                        for (let z = -gridSize/2; z <= gridSize/2; z += gridStep) {
                            const position = new THREE.Vector3(x, y, z);
                            
                            // 检查是否太接近任何电荷
                            let tooClose = false;
                            for (const charge of this.charges) {
                                if (position.distanceTo(charge.position) < 0.8) {
                                    tooClose = true;
                                    break;
                                }
                            }
                            
                            if (tooClose) continue;
                            
                            // 计算电场
                            const field = this.calculateTotalField(position);
                            const fieldStrength = field.length();
                            
                            if (fieldStrength < 0.01) continue;
                            
                            // 创建箭头
                            const arrowLength = Math.min(0.8, fieldStrength * 0.5);
                            const arrowColor = this.getFieldColor(fieldStrength);
                            const arrowDir = field.clone().normalize();
                            
                            const arrow = new THREE.ArrowHelper(
                                arrowDir,
                                position,
                                arrowLength,
                                arrowColor,
                                0.1,
                                0.05
                            );
                            
                            scene.add(arrow);
                            this.gridVectors.push(arrow);
                        }
                    }
                }
            }
            
            // 根据电场强度获取颜色
            getFieldColor(strength) {
                const maxStrength = 5.0;
                const normalized = Math.min(strength / maxStrength, 1.0);
                
                // 从蓝色(弱)到红色(强)
                const r = Math.floor(normalized * 255);
                const g = 0;
                const b = Math.floor((1 - normalized) * 255);
                
                return (r << 16) | (g << 8) | b;
            }
            
            // 清除网格矢量场
            clearGridVectors() {
                this.gridVectors.forEach(vector => scene.remove(vector));
                this.gridVectors = [];
            }
            
            // 更新二维剖面视图
            updateSectionView() {
                if (this.sectionView) {
                    const fieldLines2D = this.sectionView.extractFieldLines(this.charges);
                    this.sectionView.setCharges(this.charges);
                    this.sectionView.setFieldLines(fieldLines2D);
                    this.sectionView.draw(this);
                }
            }
            
            // 更新状态信息
            updateStatus() {
                if (!this.lastLineCounts || !this.lastTotalLines) return;
                
                // 更新电场线数量显示
                document.getElementById('totalFieldLines').textContent = this.lastTotalLines;
                
                // 更新各电荷的电场线数量
                let chargeA = this.charges.find(c => c.name === 'A');
                let chargeB = this.charges.find(c => c.name === 'B');
                
                if (chargeA) {
                    document.getElementById('chargeALines').textContent = 
                        this.lastLineCounts['A'] || chargeA.getFieldLineDensity(this.fieldLineParams.baseDensity);
                }
                
                if (chargeB) {
                    document.getElementById('chargeBLines').textContent = 
                        this.lastLineCounts['B'] || chargeB.getFieldLineDensity(this.fieldLineParams.baseDensity);
                }
                
                // 计算密度比
                if (chargeA && chargeB) {
                    const densityA = chargeA.getFieldLineDensity(this.fieldLineParams.baseDensity);
                    const densityB = chargeB.getFieldLineDensity(this.fieldLineParams.baseDensity);
                    
                    // 计算最简整数比
                    const gcd = this.greatestCommonDivisor(densityA, densityB);
                    const ratioA = densityA / gcd;
                    const ratioB = densityB / gcd;
                    
                    document.getElementById('densityRatio').textContent = `${ratioA}:${ratioB}`;
                }
            }
            
            // 计算最大公约数
            greatestCommonDivisor(a, b) {
                if (b === 0) return a;
                return this.greatestCommonDivisor(b, a % b);
            }
            
            // 更新所有电荷
            updateAllCharges() {
                this.charges.forEach(charge => {
                    charge.updateColor();
                    charge.updatePosition();
                });
                
                this.drawFieldLines();
            }
        }
        
        // 初始化电荷管理器
        const chargeManager = new ChargeManager();
        
        // 添加初始电荷
        const chargeA = chargeManager.addCharge('A', new THREE.Vector3(-2, 0, 0), 1.0);
        const chargeB = chargeManager.addCharge('B', new THREE.Vector3(2, 0, 0), 1.0);
        
        // 初始化二维剖面视图
        const sectionView = new SectionView('sectionView');
        chargeManager.setSectionView(sectionView);
        
        // 更新UI显示
        function updateUI() {
            // 更新电荷A值
            document.getElementById('chargeA').value = chargeA.charge;
            const chargeASign = chargeA.charge > 0 ? '+' : '';
            document.getElementById('chargeAValue').textContent = 
                `${chargeASign}${chargeA.charge.toFixed(1)}`;
            
            // 更新电荷B值
            document.getElementById('chargeB').value = chargeB.charge;
            const chargeBSign = chargeB.charge > 0 ? '+' : '';
            document.getElementById('chargeBValue').textContent = 
                `${chargeBSign}${chargeB.charge.toFixed(1)}`;
            
            // 更新位置值
            const positions = ['posAX', 'posAY', 'posAZ', 'posBX', 'posBY', 'posBZ'];
            const chargeAPos = [chargeA.position.x, chargeA.position.y, chargeA.position.z];
            const chargeBPos = [chargeB.position.x, chargeB.position.y, chargeB.position.z];
            
            positions.slice(0, 3).forEach((id, index) => {
                document.getElementById(id).value = chargeAPos[index];
                document.getElementById(`${id}Value`).textContent = chargeAPos[index].toFixed(1);
            });
            
            positions.slice(3).forEach((id, index) => {
                document.getElementById(id).value = chargeBPos[index];
                document.getElementById(`${id}Value`).textContent = chargeBPos[index].toFixed(1);
            });
            
            // 更新可视化参数
            document.getElementById('fieldLineBase').value = chargeManager.fieldLineParams.baseDensity;
            document.getElementById('fieldLineBaseValue').textContent = chargeManager.fieldLineParams.baseDensity;
            
            document.getElementById('arrowDensity').value = chargeManager.fieldLineParams.arrowDensity;
            document.getElementById('arrowDensityValue').textContent = chargeManager.fieldLineParams.arrowDensity;
            
            document.getElementById('fieldLineLength').value = chargeManager.fieldLineParams.maxLength;
            document.getElementById('fieldLineLengthValue').textContent = chargeManager.fieldLineParams.maxLength.toFixed(1);
            
            document.getElementById('displayMode').value = chargeManager.fieldLineParams.displayMode;
            
            // 更新二维剖面平面
            document.getElementById('sectionPlane').value = sectionView.plane;
            document.getElementById('sectionPlaneValue').textContent = sectionView.getPlaneName();
        }
        
        // 导出配置
        function exportConfig() {
            const config = {
                charges: chargeManager.charges.map(charge => ({
                    name: charge.name,
                    charge: charge.charge,
                    position: { 
                        x: charge.position.x, 
                        y: charge.position.y, 
                        z: charge.position.z 
                    }
                })),
                visualization: chargeManager.fieldLineParams,
                sectionView: {
                    plane: sectionView.plane,
                    showVectors: sectionView.showVectors,
                    showGrid: sectionView.showGrid
                }
            };
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'point_charges_config.json';
            a.click();
            URL.revokeObjectURL(url);
            
            alert('配置已导出为 point_charges_config.json');
        }
        
        // 事件监听
        // 电荷配置选择
        document.getElementById('chargeConfig').addEventListener('change', function() {
            const config = this.value;
            switch(config) {
                case 'positive':
                    chargeA.charge = 1.0;
                    chargeB.charge = 1.0;
                    break;
                case 'mixed':
                    chargeA.charge = 1.0;
                    chargeB.charge = -1.0;
                    break;
                case 'negative':
                    chargeA.charge = -1.0;
                    chargeB.charge = -1.0;
                    break;
                case 'custom':
                    // 保持当前值
                    break;
            }
            updateUI();
            chargeManager.updateAllCharges();
        });
        
        // 电荷值变化
        document.getElementById('chargeA').addEventListener('input', function() {
            chargeA.charge = parseFloat(this.value);
            const chargeASign = chargeA.charge > 0 ? '+' : '';
            document.getElementById('chargeAValue').textContent = 
                `${chargeASign}${chargeA.charge.toFixed(1)}`;
            chargeManager.updateAllCharges();
        });
        
        document.getElementById('chargeB').addEventListener('input', function() {
            chargeB.charge = parseFloat(this.value);
            const chargeBSign = chargeB.charge > 0 ? '+' : '';
            document.getElementById('chargeBValue').textContent = 
                `${chargeBSign}${chargeB.charge.toFixed(1)}`;
            chargeManager.updateAllCharges();
        });
        
        // 位置变化
        const positionSliders = ['posAX', 'posAY', 'posAZ', 'posBX', 'posBY', 'posBZ'];
        positionSliders.forEach(id => {
            document.getElementById(id).addEventListener('input', function() {
                const value = parseFloat(this.value);
                const charge = id.startsWith('posA') ? chargeA : chargeB;
                const axis = id.charAt(id.length - 1).toLowerCase();
                
                if (axis === 'x') charge.position.x = value;
                else if (axis === 'y') charge.position.y = value;
                else if (axis === 'z') charge.position.z = value;
                
                document.getElementById(`${id}Value`).textContent = value.toFixed(1);
                charge.updatePosition(); // 直接更新电荷位置和标签位置
                chargeManager.drawFieldLines(); // 重新绘制电场线
            });
        });
        
        // 可视化参数变化
        document.getElementById('fieldLineBase').addEventListener('input', function() {
            chargeManager.fieldLineParams.baseDensity = parseInt(this.value);
            document.getElementById('fieldLineBaseValue').textContent = chargeManager.fieldLineParams.baseDensity;
            chargeManager.drawFieldLines();
        });
        
        document.getElementById('arrowDensity').addEventListener('input', function() {
            chargeManager.fieldLineParams.arrowDensity = parseInt(this.value);
            document.getElementById('arrowDensityValue').textContent = chargeManager.fieldLineParams.arrowDensity;
            chargeManager.drawFieldLines();
        });
        
        document.getElementById('fieldLineLength').addEventListener('input', function() {
            chargeManager.fieldLineParams.maxLength = parseFloat(this.value);
            document.getElementById('fieldLineLengthValue').textContent = chargeManager.fieldLineParams.maxLength.toFixed(1);
            chargeManager.drawFieldLines();
        });
        
        document.getElementById('displayMode').addEventListener('change', function() {
            chargeManager.fieldLineParams.displayMode = this.value;
            chargeManager.drawFieldLines();
        });
        
        // 二维剖面平面选择
        document.getElementById('sectionPlane').addEventListener('change', function() {
            sectionView.setPlane(this.value);
            updateUI();
        });
        
        // 二维剖面视图按钮
        document.querySelectorAll('.section-btn[data-plane]').forEach(btn => {
            btn.addEventListener('click', function() {
                const plane = this.getAttribute('data-plane');
                sectionView.setPlane(plane);
                document.getElementById('sectionPlane').value = plane;
                updateUI();
                
                // 更新按钮状态
                document.querySelectorAll('.section-btn[data-plane]').forEach(b => {
                    b.classList.remove('active');
                });
                this.classList.add('active');
            });
        });
        
        // 显示/隐藏场强矢量
        document.getElementById('showFieldVectors').addEventListener('click', function() {
            const showVectors = sectionView.toggleVectors();
            this.textContent = showVectors ? '隐藏矢量' : '场强矢量';
            this.classList.toggle('active', showVectors);
            sectionView.draw(chargeManager);
        });
        
        // 显示/隐藏网格
        document.getElementById('toggleGrid').addEventListener('click', function() {
            const showGrid = sectionView.toggleGrid();
            this.textContent = showGrid ? '网格' : '无网格';
            this.classList.toggle('active', showGrid);
        });
        
        // 显示/隐藏二维视图
        let sectionViewVisible = true;
        document.getElementById('toggleSectionView').addEventListener('click', function() {
            const container = document.getElementById('sectionViewContainer');
            sectionViewVisible = !sectionViewVisible;
            container.style.display = sectionViewVisible ? 'block' : 'none';
            this.textContent = sectionViewVisible ? '隐藏二维视图' : '显示二维视图';
        });
        
        // 按钮事件
        document.getElementById('resetView').addEventListener('click', function() {
            camera.position.set(0, 8, 15);
            camera.lookAt(0, 0, 0);
            controls.reset();
        });
        
        document.getElementById('exportConfig').addEventListener('click', exportConfig);
        
        document.getElementById('addCharge').addEventListener('click', function() {
            const chargeName = String.fromCharCode(67 + chargeManager.charges.length - 2); // C, D, E...
            const randomCharge = Math.random() > 0.5 ? 1.0 : -1.0;
            const randomPos = new THREE.Vector3(
                (Math.random() - 0.5) * 6,
                (Math.random() - 0.5) * 6,
                (Math.random() - 0.5) * 6
            );
            
            chargeManager.addCharge(chargeName, randomPos, randomCharge);
            chargeManager.drawFieldLines();
            
            alert(`已添加电荷${chargeName}，位置: (${randomPos.x.toFixed(1)}, ${randomPos.y.toFixed(1)}, ${randomPos.z.toFixed(1)})，电量: ${randomCharge > 0 ? '+' : ''}${randomCharge.toFixed(1)}`);
        });
        
        // 键盘控制
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space') {
                // 空格键暂停/继续动画
                controls.autoRotate = !controls.autoRotate;
                event.preventDefault();
            }
        });
        
        // 电场强度显示
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        renderer.domElement.addEventListener('mousemove', function(event) {
            // 计算鼠标在标准化设备坐标中的位置
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // 更新射线
            raycaster.setFromCamera(mouse, camera);
            
            // 计算与地面的交点
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
            
            if (intersectionPoint) {
                // 更新坐标显示
                document.getElementById('currentPos').textContent = 
                    `(${intersectionPoint.x.toFixed(1)}, ${intersectionPoint.y.toFixed(1)}, ${intersectionPoint.z.toFixed(1)})`;
                
                // 计算电场强度
                const field = chargeManager.calculateTotalField(intersectionPoint);
                const fieldStrength = field.length();
                const fieldDirection = field.clone().normalize();
                
                // 更新电场强度显示
                document.getElementById('fieldMag').textContent = `${fieldStrength.toFixed(2)} N/C`;
                document.getElementById('fieldDir').textContent = 
                    `(${fieldDirection.x.toFixed(2)}, ${fieldDirection.y.toFixed(2)}, ${fieldDirection.z.toFixed(2)})`;
            }
        });
        
        // 窗口大小调整
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            sectionView.resize();
        });
        
        // 初始化
        function init() {
            updateUI();
            chargeManager.drawFieldLines();
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新控制器
            controls.update();
            
            // 更新电荷标签朝向相机
            chargeManager.charges.forEach(charge => {
                if (charge.label) {
                    charge.label.lookAt(camera.position);
                }
            });
            
            // 渲染场景
            renderer.render(scene, camera);
        }
        
        // 启动
        init();
        animate();
    </script>
</body>
</html>